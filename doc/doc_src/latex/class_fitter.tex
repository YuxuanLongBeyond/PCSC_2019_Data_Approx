\hypertarget{class_fitter}{}\doxysection{Fitter Class Reference}
\label{class_fitter}\index{Fitter@{Fitter}}


{\ttfamily \#include $<$Fitter.\+h$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_fitter_afa1247bad805a71020464836ca030f41}{Fitter}} (std\+::vector$<$ double $>$ \&x, std\+::vector$<$ double $>$ \&y)
\item 
std\+::vector$<$ double $>$ \mbox{\hyperlink{class_fitter_aca9ad8d72fede254e35092075abad997}{polyfit}} (int degree, double lambda) const
\item 
std\+::vector$<$ double $>$ \mbox{\hyperlink{class_fitter_a6621404da848f21af116c96b5fff4faa}{polyval}} (std\+::vector$<$ double $>$ \&w, std\+::vector$<$ double $>$ \&x\+\_\+test) const
\item 
int \mbox{\hyperlink{class_fitter_a71873abb7cc0a84d420dad8033218646}{find\+\_\+index}} (int start\+\_\+index, double v) const
\item 
std\+::vector$<$ double $>$ \mbox{\hyperlink{class_fitter_a81ee596a65d40d03b1177ce02ff0630a}{interp1}} (std\+::vector$<$ double $>$ \&x\+\_\+test) const
\item 
double \mbox{\hyperlink{class_fitter_a191ab423885608495128baed182a8dc2}{spline\+\_\+val}} (int index, double x, std\+::vector$<$ double $>$ param) const
\item 
std\+::vector$<$ double $>$ \mbox{\hyperlink{class_fitter_a4a811385fae48eae25b55364d6f21b3f}{spline}} (std\+::vector$<$ double $>$ \&x\+\_\+test) const
\item 
std\+::vector$<$ double $>$ \mbox{\hyperlink{class_fitter_a06a2b437638c7f120c4471537999b6a8}{dct\+\_\+fit}} () const
\item 
std\+::vector$<$ double $>$ \mbox{\hyperlink{class_fitter_a99e7d736d27a7b8d96a05c6002de42bb}{dct\+\_\+val}} (std\+::vector$<$ double $>$ \&w, std\+::vector$<$ double $>$ \&x\+\_\+test) const
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
In this class, we aim to solve data fitting problem. Given a set of 2D points \{(x\+\_\+i, y\+\_\+i)\}, we want to approximate a function f s.\+t. f(x\+\_\+i) = y\+\_\+i, where f can have its parameter w.

This class provides the implementation of four methods for data fitting (or interpolation)\+:
\begin{DoxyEnumerate}
\item Polynomial fitting, i.\+e. polyfit, polyval
\item Linear piecewise interpolation, i.\+e. interp1
\item Cubic spline interpolation, i.\+e. spline
\item Fourier interpolation, i.\+e. dct\+\_\+fit, dct\+\_\+val
\end{DoxyEnumerate}

Note that the usages of the previous three methods are very similar to the ones in Matlab. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_fitter_afa1247bad805a71020464836ca030f41}\label{class_fitter_afa1247bad805a71020464836ca030f41}} 
\index{Fitter@{Fitter}!Fitter@{Fitter}}
\index{Fitter@{Fitter}!Fitter@{Fitter}}
\doxysubsubsection{\texorpdfstring{Fitter()}{Fitter()}}
{\footnotesize\ttfamily Fitter\+::\+Fitter (\begin{DoxyParamCaption}\item[{std\+::vector$<$ double $>$ \&}]{x,  }\item[{std\+::vector$<$ double $>$ \&}]{y }\end{DoxyParamCaption})}

Constructor for loading the input data of x and y Note x and y here are 1D vectors having the same size 
\begin{DoxyParams}{Parameters}
{\em x} & input 1D vector X containing all scalar samples x\+\_\+i \\
\hline
{\em y} & input 1D vector Y containing all scalar samples y\+\_\+i which correspond to x\+\_\+i \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_fitter_a06a2b437638c7f120c4471537999b6a8}\label{class_fitter_a06a2b437638c7f120c4471537999b6a8}} 
\index{Fitter@{Fitter}!dct\_fit@{dct\_fit}}
\index{dct\_fit@{dct\_fit}!Fitter@{Fitter}}
\doxysubsubsection{\texorpdfstring{dct\_fit()}{dct\_fit()}}
{\footnotesize\ttfamily std\+::vector$<$ double $>$ Fitter\+::dct\+\_\+fit (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Computation of real Fourier coefficients by discrete cosine transform (D\+CT); It assumes that the data points stored are real, periodic and evenly spaced \begin{DoxyReturn}{Returns}
the real coefficients for D\+CT 
\end{DoxyReturn}
\mbox{\Hypertarget{class_fitter_a99e7d736d27a7b8d96a05c6002de42bb}\label{class_fitter_a99e7d736d27a7b8d96a05c6002de42bb}} 
\index{Fitter@{Fitter}!dct\_val@{dct\_val}}
\index{dct\_val@{dct\_val}!Fitter@{Fitter}}
\doxysubsubsection{\texorpdfstring{dct\_val()}{dct\_val()}}
{\footnotesize\ttfamily std\+::vector$<$ double $>$ Fitter\+::dct\+\_\+val (\begin{DoxyParamCaption}\item[{std\+::vector$<$ double $>$ \&}]{w,  }\item[{std\+::vector$<$ double $>$ \&}]{x\+\_\+test }\end{DoxyParamCaption}) const}

Inverse discrete cosine transform (I\+D\+CT) for Fourier interpolation 
\begin{DoxyParams}{Parameters}
{\em w} & the real coefficients of D\+CT, usually obtained from the function \mbox{\hyperlink{class_fitter_a06a2b437638c7f120c4471537999b6a8}{dct\+\_\+fit()}} \\
\hline
{\em x\+\_\+test} & a vector of test data points being evaluated for Fourier interpolation \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the interpolated values corresponding to the input test points 
\end{DoxyReturn}
\mbox{\Hypertarget{class_fitter_a71873abb7cc0a84d420dad8033218646}\label{class_fitter_a71873abb7cc0a84d420dad8033218646}} 
\index{Fitter@{Fitter}!find\_index@{find\_index}}
\index{find\_index@{find\_index}!Fitter@{Fitter}}
\doxysubsubsection{\texorpdfstring{find\_index()}{find\_index()}}
{\footnotesize\ttfamily int Fitter\+::find\+\_\+index (\begin{DoxyParamCaption}\item[{int}]{start\+\_\+index,  }\item[{double}]{v }\end{DoxyParamCaption}) const}

Find the index of the largest sample point smaller than the input point; It also assumes that the input data x are in increasing order; This function is used in finding the interval for interpolation 
\begin{DoxyParams}{Parameters}
{\em start\+\_\+index} & a lower bound of the returned index \\
\hline
{\em v} & the scalar input point \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the index of the largest sample point smaller than the input point v 
\end{DoxyReturn}
\mbox{\Hypertarget{class_fitter_a81ee596a65d40d03b1177ce02ff0630a}\label{class_fitter_a81ee596a65d40d03b1177ce02ff0630a}} 
\index{Fitter@{Fitter}!interp1@{interp1}}
\index{interp1@{interp1}!Fitter@{Fitter}}
\doxysubsubsection{\texorpdfstring{interp1()}{interp1()}}
{\footnotesize\ttfamily std\+::vector$<$ double $>$ Fitter\+::interp1 (\begin{DoxyParamCaption}\item[{std\+::vector$<$ double $>$ \&}]{x\+\_\+test }\end{DoxyParamCaption}) const}

Linear piecewise interpolation 
\begin{DoxyParams}{Parameters}
{\em x\+\_\+test} & the test data points to be interpolated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the polynomial values evaluated at corresponding test data points 
\end{DoxyReturn}
\mbox{\Hypertarget{class_fitter_aca9ad8d72fede254e35092075abad997}\label{class_fitter_aca9ad8d72fede254e35092075abad997}} 
\index{Fitter@{Fitter}!polyfit@{polyfit}}
\index{polyfit@{polyfit}!Fitter@{Fitter}}
\doxysubsubsection{\texorpdfstring{polyfit()}{polyfit()}}
{\footnotesize\ttfamily std\+::vector$<$ double $>$ Fitter\+::polyfit (\begin{DoxyParamCaption}\item[{int}]{degree,  }\item[{double}]{lambda = {\ttfamily 0.001} }\end{DoxyParamCaption}) const}

Polynomial fitting (non-\/piecewise) with some degree 
\begin{DoxyParams}{Parameters}
{\em degree} & degree of polynomial being approximated \\
\hline
{\em lambda} & small non-\/negative number to be added on the diagonal when solving the linear system \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the optimized parameter w for the polynomial. Note w has length of degree + 1 
\end{DoxyReturn}
\mbox{\Hypertarget{class_fitter_a6621404da848f21af116c96b5fff4faa}\label{class_fitter_a6621404da848f21af116c96b5fff4faa}} 
\index{Fitter@{Fitter}!polyval@{polyval}}
\index{polyval@{polyval}!Fitter@{Fitter}}
\doxysubsubsection{\texorpdfstring{polyval()}{polyval()}}
{\footnotesize\ttfamily std\+::vector$<$ double $>$ Fitter\+::polyval (\begin{DoxyParamCaption}\item[{std\+::vector$<$ double $>$ \&}]{w,  }\item[{std\+::vector$<$ double $>$ \&}]{x\+\_\+test }\end{DoxyParamCaption}) const}

Evaluation of the approximated polynomial given the test sample points 
\begin{DoxyParams}{Parameters}
{\em w} & the optimized parameter w for the polynomial, usually obtained from \mbox{\hyperlink{class_fitter_aca9ad8d72fede254e35092075abad997}{polyfit()}} \\
\hline
{\em x\+\_\+test} & 1D vector containing the test sample points \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1D vector containing the evaluated polynomial values corresponding to the test sample points 
\end{DoxyReturn}
\mbox{\Hypertarget{class_fitter_a4a811385fae48eae25b55364d6f21b3f}\label{class_fitter_a4a811385fae48eae25b55364d6f21b3f}} 
\index{Fitter@{Fitter}!spline@{spline}}
\index{spline@{spline}!Fitter@{Fitter}}
\doxysubsubsection{\texorpdfstring{spline()}{spline()}}
{\footnotesize\ttfamily std\+::vector$<$ double $>$ Fitter\+::spline (\begin{DoxyParamCaption}\item[{std\+::vector$<$ double $>$ \&}]{x\+\_\+test }\end{DoxyParamCaption}) const}

Cubic spline interpolation by solving a large linear system 
\begin{DoxyParams}{Parameters}
{\em x\+\_\+test} & a vector of test data points being evaluated for interpolation \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the evaluated polynomial value corresponding to all input sample points 
\end{DoxyReturn}
\mbox{\Hypertarget{class_fitter_a191ab423885608495128baed182a8dc2}\label{class_fitter_a191ab423885608495128baed182a8dc2}} 
\index{Fitter@{Fitter}!spline\_val@{spline\_val}}
\index{spline\_val@{spline\_val}!Fitter@{Fitter}}
\doxysubsubsection{\texorpdfstring{spline\_val()}{spline\_val()}}
{\footnotesize\ttfamily double Fitter\+::spline\+\_\+val (\begin{DoxyParamCaption}\item[{int}]{index,  }\item[{double}]{x,  }\item[{std\+::vector$<$ double $>$}]{param }\end{DoxyParamCaption}) const}

Evaluate the approximated polynomial given one test sample point 
\begin{DoxyParams}{Parameters}
{\em index} & the index for extracting the parameters for one piece of the cubic polynomial \\
\hline
{\em x} & the sample point to be evaluated \\
\hline
{\em param} & all the parameters for the piecewise polynomials \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the evaluated polynomial value corresponding to the input sample point 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/Fitter.\+h\item 
src/Fitter.\+cpp\end{DoxyCompactItemize}
